一：命名
    1：go语言命名：
            函数名、变量名、常量名、类型名、语句标记和包名等所有的命名，都必须以字母或者下划线开头，后面可以跟任意数量的字母、数字、下划线。并区分大小写
    2：关键字：
            break  default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var
            此外还有大约30个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
            内建常量：true false iota nil
            内建类型：int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error
            内建函数：make len cap new append copy close delete complex real imag panic recover
            这些内部预定义的名字并不是关键字， 可以在定义中重新使用他们，在一些特殊的场景中重新定义它们也是有意义的，但也要避免过度引起的语义混乱。
    3：如果一个命名在函数内定义，那么它的作用域就只是这个函数，如果在函数外定义，那么作用域就是当前包。
    4：命名的开头字母大小写决定命名在保外的可见性。如果大写开头，那么它就是可导出的，也就是说在包外也可以访问。例如：fmt包的Printf函数 就是可以导出的，也可以在fmt包外访问。 包本身的命名一般都是小写字母
    5：命名的长度没有逻辑限制，但是go语言的更个是尽量用短小的命名，对于局部变量尤其是这样。通常来说，如果一个命名的作用域比较大，生命周期也比较长，那么用常命名将会更有意义。
    6：习惯上go语言推荐使用驼峰式命名，当名字有几个单词组成时，先使用大小写分割，而不是先用下划线分割。因此在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但一般不会用quote_rune_to_ASCII这样的命名。
       而ASCII和HTML这样的缩写词则避免使用大小写混合的写法，他们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。

二：声明
    1：声明语句定义了程序的各种实体对象以及部分或全部的属性。go语言主要又四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函实体对象的声明数。
       一个go语言编写的程序对应一个或多个以.go为文件后缀的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其他包，然后是包一级的类型、变量、常量、函数的声明语句，
       包一级的各种类型的声明语句的顺序无关紧要（注意：函数内部的命名必须先声明后使用）。
    2：包一级的声明语句声明的命名可以在整个包对应的每个原文件中访问，而不是仅仅在其声明的语句所在的源文件中访问。相比之下，局部变量的命名就只能在函数内部很小的范围被访问。
    3：一个函数的声明由一个函数命名、参数列表（由函数的调用者提供参数变量的具体值【形参->实参】）、一个可选的返回值列表和包含函数定义的函数体组成。函数可以没有返回值。

三：变量
    1：var声明语句可以创建一个特定类型的变量，然后给变量附加一个命名，并且设置变量的初始值。变量声明的一般语法如下：
        var 变量名 类型 = 表达式
        其中『类型』或 『= 表达式』两部分可以省略其中一个。
        ① 如果省略的是类型，那么将根据初始化表达式来推算变量的类型。
        ② 如果省略的是表达式，数值类型对应的零值是0.而布尔值变量对应的零值是false。字符串对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
        零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在go语言中不存在未初始化的变量。这个特性可以简化很多代码。而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。
        例如：
            ① var s string
              fmt.Println(s)   // ""

            ② var i, j, k int // int, int, int
              var b, f, s = true, 2.3, "four" // bool, float64, string

            ③ var f, err = os.Open(name) // os.Open 返回 一个文件 和一个错误码
    2：简短变量声明
        在函数内部，有一种称为简短变量声明的语句形式可以用于声明和初始化局部变量。形式如下：
        anim := gif.GIF{LoopCount: nframes}
        freq := rand.Float64() * 3.0
        t := 0.0
        因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化上，var形式的声明语句往往是用于需要显示和制定变量类型的地方。，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

        注意：简短变量声明左边的变量可能并不全都是刚刚声明的。如果有些已经存在相同的语法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。
              ****简短变量声明语句中必须至少要声明一个新的变量。***
              简短变量声明语句只对已经在同级语法域声明过的变量才和赋值操作语句等价，如果变量是在外部语法域声明的，那么简短声明语句将会在当前语法域重新声明一个新的变量。
    3：指针
        ① 一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名上，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i] 或x.f变量。所有这些表达式一般都是读取一个变量的值，除非他们是出现在赋值语句的左边，
        这时候是给对应变量赋予新值。
        ② 对于聚合类型每个成员，比如结构体的每个字段或者是数组的每个元素 也都是对应一个变量，因此可以被取地址。
        ③ 变量有时候被称为可寻址的值。及时变量由表达式生成，那么表达式也必须能接受 & 取地址操作。 即引用。
        ④ 任何类型的指针的零值都是nil 。 指针之间也是可以进行相等测试，只有当它们指向同一个变量或全部是nil时才想等。
          例如：
            var x, y int
            fmt.Println(&x == &x, &x == &y, &x == nil) // true false false
        ⑤ 如果指针作为参数调用函数，将可以在函数中国通该指针来更新变量的值， 因为指针包含了一个变量的地址。
    4：new函数
        ① 另一个创建变量的方法是调用内建的new函数，表达式new(T) 创建一个T类型的匿名变量，初始化为T类型的零值， 然后返回变量地址，返回的指针类型为*T
        ② 每次调用new函数都是返回一个新的变量地址，因此下面两个地址是不同的：
            p := new(int)
            q := new(int)
            fmt.Println(p == q) //false
        ③ 也有特殊情况存在：如果两个类型都是空的，也就是说类型的大小都是0，如：struct{} 和[0]int， 有可能有相同的地址（依赖具体的语言实现）（请谨慎使用大小为0的类型， 因为如果类型的大小位0好话，可能导致go语言的自动垃圾回收器有不同行为，具体查看runtime.SetFinalizer函数相关文档）
        ④ new函数使用相对比较少见，因为对应结构体来说，可以直接用字面量语法创建新变量更为灵活。
        ⑤ 因为new只是一个预定义的函数，并不是一个关键字，因此我们可以将new明明重新定义为别的类型。
          例如：
          func delta(old, new int) int {return new - old}
    5：变量的生命周期
        ① 变量的生命周期指的是在程序运行期间变量的有效时间间隔。 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，在局部变量的生命周期则是动态的：从每次创建一个新的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。
          函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用时创建。
        ② 函数的右小括号可以另起一行缩进，同事为了防止编译器在行尾自动插入分号而导致编译错误，可以在末尾的参数变量后面插入都好。
          例如：
          for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(
                size + int(x * size + 0.5), size + int(y * size + 0.5),
                blackIndex, //最后插入的都好不会导致编译错误， 这是go编译器的一个特性
                ) //小括号另起一行缩进， 和大括号的风格保持一致
          }
        ③ 逃逸的变量需要额外分配内存，同事对性能的优化可能会产生细微的影响。 （逃逸指的是在函数内部定义的变量， 可以在外面使用了 就说明该变量逃逸了）
          例如：
                var global *int
                func f() {
                    var x int
                    x = 1
                    global = &x  //这里的x就是逃逸变量 我觉得应该理解成是：局部变量 被全局变量引用
                }
四：赋值
    1：使用赋值语句可以更新一个变量的值，最简单的复制语句就是将要被复制的变量放在=的左边。新值的表达式放在=的右边。
       例如：
            x = 1               //命令变量的赋值
            *p = true           //通过指针间接赋值
            person.name = "bob" //结构体字段赋值
            count[x] = count[x] * scale //数组、slice或map的元素赋值
    2：特定的二元运算符和赋值语句的复合操作有一个简洁的模式，
       例如：
            count[x] *= scale
    3：元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值前，赋值语句右边的所有表达式将会先进行求值运算， 然后统一更新左边变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样叫唤两个变量的值：
       x, y = y, x
       a[i], a[j] = a[j], a[i]
    ① ：欧几里得的GCD最早的非凡算法：
    func gcd(x, y int) int {
        for y != 0 {
            x, y = y, x%y
        }
        return x
    }
    ② ：裴波那契数列(Fibonacci)的第N个数：
    func fib(n int) int {
        x, y := 0, 1
        for i := 0; i < n; i++ {
            x, y = y, x + y
        }
        rerturn x
    }
    ③ ：但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性更好。
五：类型
    1：类型的声明语句一般出现在包一级，因此如果新创建的类型名称的首字母大写，则在外部包也可以使用。
       对于中文汉字，Unicode标识都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出自己的的见解，
    2：表达式写法：
            type 类型名称 底层类型
            例如： type note string    //note 这个类型  底层是字符串类型的
    3：比較運算符==和<也可以用來比較一個命名類型的變量和另一個有相同類型的變量或有相同底層類型的值做比較。但是如果兩個值有着不同的類型，則不能直接進行比較。

六：包和文件
    1：go语言中的包和其他语言的库或模块的概念类似，都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个.go源文件中，通常一个包所在的路径的后缀是包的导入路径。
        例如：包gopl.io/ch1/helloworld 对应的路径是$GOPATH/src/gopl.io/ch1/helloworld
    2：每个包都对应一个独立的命名空间。
        例如：在image包中，Decode函数和unicode/utf16包里Decode函数是不同的。要在外部引用该函数，必须使用image.Decode或utf16.Decode形式。
    3：包还可以让我们通过控制哪些命名是外部可见的来隐藏内部实现信息。在go语言中，
    一个简单的规则是：如果一个命名是大写字母开头的，那么该命就是可导出的（注意：因汉字不区分大小写，所以汉字的命名是不能导出的。 也就是说可以汉字当变量名咯！！！）
    4：如何发布我自己的包？(例子里的39.go  40.go)
        ① ：每个源文件都是以包的声明语句开始，用来指定包的名称。当包被引入的时候，包内的成员将通过类似tempconv.CToF的形式访问。 而包级别的命名，例如在一个文件声明的类型和常量，在同一个包的其他源文件里也是可以直接访问的，就好像所有代码都在一个文件一样。需要注意的是多个文件引入外部文件也需要单独去引入。  例如：引入fmt包。
        ② ：因为包级别的常量名都是以大写字母开头， 它们可以像tempconv.AbsoluteZeroC这样被外部代码访问。
            例如：fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC)
        ③ ：在go语言中， 每个包都有一个全局唯一的导入路径，导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。go语言并没有规范这些字符串的具体含义或包的来源，它们是由构建工具来解释的。当go语言自带的go工具被使用时，一个导入路径代表一个目录中的一个或多个go源文件。
        除了包的导入路径，每个包还有一个包名，包名一般都是短小的名称（并不要求包名是唯一的 ）， 包名在包的声明处指定。
        按照惯例，一个包的名称和包的导入路径的最后一个字段相同， 例如：gopl.io/ch2/tempconv包的名称一般是tempconv。要使用这个包，需要先导入。
    综上所述：发布包: 其实就是把自己写的包文件的第一行package 命名都是一样的  然后再把整个包文件都一起放到自己的$GOPATH/src/定义一个名字 然后放里面  引入的时候引入最后的这个文件夹名称（文件夹名称需要和路径的最后一个名称一样）然后就可以使用了。。。。
    5：包的初始化
        包的初始化首先是解决包级变量和依赖顺序，然后按照包级变量声明出现的顺序依次初始化；
        如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，go语言的构建工具将.go文件根据文件名排序，然后一次调用编译器编译。
        对于在包级声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数
        func init() {....}
        这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
        每个包在解决依赖的前提下，可以导入声明的顺序初始化，每个包只初始化一次。因此一个p包导入了q包，那么在p包初始化的时候就可以认为q包也必然已经初始化过了，初始化工作是自下而上进行的。main包最后被初始化。以这样的方式可以确保在main函数执行之前所有的包都已经完成了初始化工作。
七：作用域
    1：一个声明语句将程序中的实体和一个命名关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个命名的范围。
    2：不要将作用域和生命周期混为一谈，声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时候的属性。
    3：一个变量的生命周期指的是程序运行时变量存在的有效时间段，在此期间内它可以被程序的其他部分引用，是一个运行时的概念。
    4： 语法块是由花括号包含的一系列语句， 就像函数体或循环体花括号对应的语法块那样。
        语法块内部声明的命名无法被外部语法块访问。
        语法块决定了内部声明的命名的作用域范围。
    5：声明语句对应的语法域决定作用域范围的大小。
    6：对于内置的类型、函数、和常量，如int、len、true等是全局作用域的。
    7：任何在函数外部（也就是包级语法域）声明的命名可以在同一个包的任何源文件中访问。
    8：对于导入的包是对应源文件级的作用域。 例如当前文件中导入fmt包，当前包的其他源文件无法访问在当前源文件导入的包。
    9：控制流标号，即break、continue、 goto语句后面跟着的那种标号，则是函数级的作用域。
    10：一个程序可能含有多个同名的声明，在固态它们在不同的语法域就没有关系。 如果滥用不同语法域可重命名这个特性的话，可能造成程序很难阅读。
    11：当编译器遇到一个引用的变量时，如果它看起来像是一个声明，它首先从最内层的语法域向全局的作用域查找。查找失败就会报告"未声明该变量"的错误，
        如果该命名在内部和外部的块分别声明过，则内部块的声明先被找到。这种情况下，内部声明屏蔽了外部同名的声明，让外部声明的命名无法被访问。
八：基础数据类型
  1：虽然从底层语言来讲所有类型都是以比特（byte）组成,但计算机操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将这些数组织中一起就可以表达更多等对象。例如数据包、像素点、诗歌甚至其他对象，这依赖于go语言内置等数据类型。这些内置数据类型，兼顾了硬件等特性和表达复杂数据结构等便捷性。
  2:go语言等数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
  3:基础类型包括：数字、字符串、布尔值；
  4:复合类型包括：数组、结构体（通过组合简单类型来表达更复杂等数据结构）；
  5:引用类型包括：指针、切片、字典、函数、通道、
  虽然数据种类较多，但它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。

  6:整型
    ① go语言的数值类型包括几种不同大小的整型数、浮点数、负数。每种数值类型都决定了对应的大小范围和是否支持正负符号。

    ② go同时支持有符号整数和无符号整数：
      int8      8bit 有符号整数
      int16     16bit 有符号整数
      int32     32bit 有符号整数
      int64     64bit 有符号整数

      unit8     8bit 无符号整数
      unit16    16bit 无符号整数
      unit32    32bit 无符号整数
      unit64    64bit 无符号整数

    ③ Go語言同時提供了有符號和無符號類型的整數運算。這里有int8、int16、int32和int64四種截然不同大小的有符號整形數類型，分别對應8、16、32、64bit大小的有符號整形數，與此對應的是uint8、uint16、uint32和uint64四種無符號整形數類型.

    ④ 這里還有兩種一般對應特定CPU平台機器字大小的有符號和無符號整數int和uint；其中int是應用最廣泛的數值類型。這兩種類型都有同樣的大小，32或64bit，但是我們不能對此做任何的假設；因爲不同的編譯器卽使在相同的硬件平台上可能産生不同的大小。

    ⑤ Unicode字符rune類型是和int32等價的類型，通常用於表示一個Unicode碼點。這兩個名稱可以互換使用。同樣byte也是uint8類型的等價類型，byte類型一般用於強調數值是一個原始的數據而不是一個小的整數。

    ⑥ 最後，還有一種無符號的整數類型uintptr，沒有指定具體的bit大小但是足以容納指針。uintptr類型隻有在底層編程是才需要，特别是Go語言和C語言函數庫或操作繫統接口相交互的地方。我們將在第十三章的unsafe包相關部分看到類似的例子。

    ⑦ 不管它們的具體大小，int、uint和uintptr是不同類型的兄弟類型。其中int和int32也是不同的類型，卽使int的大小也是32bit，在需要將int當作int32類型的地方需要一個顯式的類型轉換操作，反之亦然。

    ⑧ 其中有符號整數采用2的補碼形式表示，也就是最高bit位用作表示符號位，一個n-bit的有符號數的值域是從-2的n-1次方 到 2的n-1次方。無符號整數的所有bit位都用於表示非負數，值域是0到2的n-1次方。例如，int8類型整數的值域是從-128到127，而uint8類型整數的值域是從0到255。

    ⑨ 算術運算、邏輯運算和比較運算的二元運算符，它們按照先級遞減的順序的排列:
        *      /      %      <<       >>     &       &^
        +      -      |      ^
        ==     !=     <      <=       >      >=
        &&
        ||
    二元運算符有五種優先級。在同一個優先級，使用左優先結合規則，但是使用括號可以明確優先順序，使用括號也可以用於提陞優先級。
    對於上表中前兩行的運算符，例如+運算符還有一個與賦值相結合的對應運算符+=，可以用於簡化賦值語句。

    整數的算術運算符+、-、*和/可以適用與於整數、浮點數和複數，但是取模運算符%僅用於整數間的運算。對於不同編程語言，%取模運算的行爲可能併不相同。在Go語言中，%取模運算符的符號和被取模數的符號總是一致的，因此-5%3和-5%-3結果都是-2。除法運算符/的行爲則依賴於操作數是否爲全爲整數，比如5.0/4.0的結果是1.25，但是5/4的結果是1，因爲整數除法會向着0方向截斷餘數。

    如果一個算術運算的結果，不管是有符號或者是無符號的，如果需要更多的bit位才能正確表示的話，就説明計算結果是溢出了。超出的高位的bit位部分將被丟棄。如果原始的數值是有符號類型，而且最左邊的bit爲是1的話，那麽最終結果可能是負的。

****注意： 运用整形的时候  需要注意取值范围。

    两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。
    ==    equal to                          相等
    !=    not equal to                      不等
    <     less than                         小于
    <=    less than or equal to             小于等于
    >     greater than                      大于
    >=    greater than or equal to          大于等于

    事实上，布尔类型、数字类型和字符串类型等基本类型都是可以比较的，也就是说两个相同类型的值可以用==和!=进行比较。此外，整数、浮点数和字符串可以根据比较结果排序。许多其他类型的值可能是不可以比较的。因此也就是可能是不能排序的。 对于遇到的每种类型，我们要保证规则的一致性。
    對於整數，+x是0+x的簡寫，-x則是0-x的簡寫；對於浮點數和複數，+x就是x，-x則是x 的負數。

    Go語言還提供了以下的bit位操作運算符，前面4個操作運算符併不區分是有符號還是無符號數。
    &      位運算 AND
    |      位運算 OR
    ^      位運算 XOR
    &^     位清空 (AND NOT)
    <<     左移
    >>     右移
    位操作運算符^作爲二元運算符時是按位異或（XOR），當用作一元運算符時表示按位取反；也就是説，它返迴一個每個bit位都取反的數。
    位操作運算符&^用於按位置零（AND NOT）：表達式z = x &^ y結果z的bit位爲0，如果對應y中bit位爲1的話，否則對應的bit位等於x相應的bit位的值。
**********
    在x<<n和x>>n移位運算中，決定了移位操作bit數部分必鬚是無符號數；被操作的x數可以是有符號或無符號數。算術上，一個x<<n左移運算等價於乘以2的n次方​​ ，一個x>>n右移運算等價於除以2的n次方。
    左移運算用零填充右邊空缺的bit位，
    無符號數的右移運算也是用0填充左邊空缺的bit位，
    但是有符號數的右移運算會用符號位的值填充左邊空缺的bit位，
    因爲這個原因，最好用無符號運算，這樣你可以將整數完全當作一個bit位模式處理。
    盡管Go語言提供了無符號數和運算，卽使數值本身不可能出現負數我們還是傾向於使用有符號的int類型，就像數組的長度那樣，雖然使用uint無符號類型似乎是一個更合理的選擇。
**********
