一：命名
    1：go语言命名：
            函数名、变量名、常量名、类型名、语句标记和包名等所有的命名，都必须以字母或者下划线开头，后面可以跟任意数量的字母、数字、下划线。并区分大小写
    2：关键字：
            break  default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var
            此外还有大约30个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
            内建常量：true false iota nil
            内建类型：int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error
            内建函数：make len cap new append copy close delete complex real imag panic recover
            这些内部预定义的名字并不是关键字， 可以在定义中重新使用他们，在一些特殊的场景中重新定义它们也是有意义的，但也要避免过度引起的语义混乱。
    3：如果一个命名在函数内定义，那么它的作用域就只是这个函数，如果在函数外定义，那么作用域就是当前包。
    4：命名的开头字母大小写决定命名在保外的可见性。如果大写开头，那么它就是可导出的，也就是说在包外也可以访问。例如：fmt包的Printf函数 就是可以导出的，也可以在fmt包外访问。 包本身的命名一般都是小写字母
    5：命名的长度没有逻辑限制，但是go语言的更个是尽量用短小的命名，对于局部变量尤其是这样。通常来说，如果一个命名的作用域比较大，生命周期也比较长，那么用常命名将会更有意义。
    6：习惯上go语言推荐使用驼峰式命名，当名字有几个单词组成时，先使用大小写分割，而不是先用下划线分割。因此在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但一般不会用quote_rune_to_ASCII这样的命名。
       而ASCII和HTML这样的缩写词则避免使用大小写混合的写法，他们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。

二：声明
    1：声明语句定义了程序的各种实体对象以及部分或全部的属性。go语言主要又四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函实体对象的声明数。
       一个go语言编写的程序对应一个或多个以.go为文件后缀的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其他包，然后是包一级的类型、变量、常量、函数的声明语句，
       包一级的各种类型的声明语句的顺序无关紧要（注意：函数内部的命名必须先声明后使用）。
    2：包一级的声明语句声明的命名可以在整个包对应的每个原文件中访问，而不是仅仅在其声明的语句所在的源文件中访问。相比之下，局部变量的命名就只能在函数内部很小的范围被访问。
    3：一个函数的声明由一个函数命名、参数列表（由函数的调用者提供参数变量的具体值【形参->实参】）、一个可选的返回值列表和包含函数定义的函数体组成。函数可以没有返回值。

三：变量
    1：var声明语句可以创建一个特定类型的变量，然后给变量附加一个命名，并且设置变量的初始值。变量声明的一般语法如下：
        var 变量名 类型 = 表达式
        其中『类型』或 『= 表达式』两部分可以省略其中一个。
        ① 如果省略的是类型，那么将根据初始化表达式来推算变量的类型。
        ② 如果省略的是表达式，数值类型对应的零值是0.而布尔值变量对应的零值是false。字符串对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
        零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在go语言中不存在未初始化的变量。这个特性可以简化很多代码。而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。
        例如：
            ① var s string
              fmt.Println(s)   // ""

            ② var i, j, k int // int, int, int
              var b, f, s = true, 2.3, "four" // bool, float64, string

            ③ var f, err = os.Open(name) // os.Open 返回 一个文件 和一个错误码
    2：简短变量声明
        在函数内部，有一种称为简短变量声明的语句形式可以用于声明和初始化局部变量。形式如下：
        anim := gif.GIF{LoopCount: nframes}
        freq := rand.Float64() * 3.0
        t := 0.0
        因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化上，var形式的声明语句往往是用于需要显示和制定变量类型的地方。，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

        注意：简短变量声明左边的变量可能并不全都是刚刚声明的。如果有些已经存在相同的语法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。
              ****简短变量声明语句中必须至少要声明一个新的变量。***
              简短变量声明语句只对已经在同级语法域声明过的变量才和赋值操作语句等价，如果变量是在外部语法域声明的，那么简短声明语句将会在当前语法域重新声明一个新的变量。
    3：指针
        ① 一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名上，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i] 或x.f变量。所有这些表达式一般都是读取一个变量的值，除非他们是出现在赋值语句的左边，
        这时候是给对应变量赋予新值。
        ② 对于聚合类型每个成员，比如结构体的每个字段或者是数组的每个元素 也都是对应一个变量，因此可以被取地址。
        ③ 变量有时候被称为可寻址的值。及时变量由表达式生成，那么表达式也必须能接受 & 取地址操作。 即引用。
        ④ 任何类型的指针的零值都是nil 。 指针之间也是可以进行相等测试，只有当它们指向同一个变量或全部是nil时才想等。
          例如：
            var x, y int
            fmt.Println(&x == &x, &x == &y, &x == nil) // true false false
        ⑤ 如果指针作为参数调用函数，将可以在函数中国通该指针来更新变量的值， 因为指针包含了一个变量的地址。
    4：new函数
        ① 另一个创建变量的方法是调用内建的new函数，表达式new(T) 创建一个T类型的匿名变量，初始化为T类型的零值， 然后返回变量地址，返回的指针类型为*T
        ② 每次调用new函数都是返回一个新的变量地址，因此下面两个地址是不同的：
            p := new(int)
            q := new(int)
            fmt.Println(p == q) //false
        ③ 也有特殊情况存在：如果两个类型都是空的，也就是说类型的大小都是0，如：struct{} 和[0]int， 有可能有相同的地址（依赖具体的语言实现）（请谨慎使用大小为0的类型， 因为如果类型的大小位0好话，可能导致go语言的自动垃圾回收器有不同行为，具体查看runtime.SetFinalizer函数相关文档）
        ④ new函数使用相对比较少见，因为对应结构体来说，可以直接用字面量语法创建新变量更为灵活。
        ⑤ 因为new只是一个预定义的函数，并不是一个关键字，因此我们可以将new明明重新定义为别的类型。
          例如：
          func delta(old, new int) int {return new - old}
    5：变量的生命周期
        ① 变量的生命周期指的是在程序运行期间变量的有效时间间隔。 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，在局部变量的生命周期则是动态的：从每次创建一个新的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。
          函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用时创建。
        ② 函数的右小括号可以另起一行缩进，同事为了防止编译器在行尾自动插入分号而导致编译错误，可以在末尾的参数变量后面插入都好。
          例如：
          for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(
                size + int(x * size + 0.5), size + int(y * size + 0.5),
                blackIndex, //最后插入的都好不会导致编译错误， 这是go编译器的一个特性
                ) //小括号另起一行缩进， 和大括号的风格保持一致
          }
        ③ 逃逸的变量需要额外分配内存，同事对性能的优化可能会产生细微的影响。 （逃逸指的是在函数内部定义的变量， 可以在外面使用了 就说明该变量逃逸了）
          例如：
                var global *int
                func f() {
                    var x int
                    x = 1
                    global = &x  //这里的x就是逃逸变量 我觉得应该理解成是：局部变量 被全局变量引用
                }
四：赋值
    1：使用赋值语句可以更新一个变量的值，最简单的复制语句就是将要被复制的变量放在=的左边。新值的表达式放在=的右边。
       例如：
            x = 1               //命令变量的赋值
            *p = true           //通过指针间接赋值
            person.name = "bob" //结构体字段赋值
            count[x] = count[x] * scale //数组、slice或map的元素赋值
    2：特定的二元运算符和赋值语句的复合操作有一个简洁的模式，
       例如：
            count[x] *= scale
    3：元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值前，赋值语句右边的所有表达式将会先进行求值运算， 然后统一更新左边变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样叫唤两个变量的值：
       x, y = y, x
       a[i], a[j] = a[j], a[i]
    ① ：欧几里得的GCD最早的非凡算法：
    func gcd(x, y int) int {
        for y != 0 {
            x, y = y, x%y
        }
        return x
    }
    ② ：裴波那契数列(Fibonacci)的第N个数：
    func fib(n int) int {
        x, y := 0, 1
        for i := 0; i < n; i++ {
            x, y = y, x + y
        }
        rerturn x
    }
    ③ ：但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性更好。
五：类型
    1：
