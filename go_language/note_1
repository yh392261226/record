视频地址：
http://study.163.com/course/courseLearn.htm?courseId=306002&from=study#/learn/video?lessonId=421012&courseId=306002
笔记：【开发环境的搭建】
1：
什么是go？
go是一门并发支持、垃圾回收的编译型系统编程语言，旨在创造一门具有在静态编译语言的高性能和动态语言的高开发之间拥有良好平衡点的一门语言。

2：
主要特点：
类型安全和内存安全，
以非常直观和极低代价的方案实现高并发，
高效的垃圾回收机制，
快速编译（同时解决c语言中文件头太多的问题,当编译时有不使用的包被引入就会有提示错误），
为多核计算机提供性能提升方案，
UTF-8编码支持。

3：
go语言是为了解决服务端问题而出现的。

4：
go语言目录结构
bin目录  生成的可执行文件生成的地方(二进制)
pkg目录  是包文件地址 （将src目录下的源码包编译成.a的包文件 放在这里）
src目录  源码目录
    main.go 主文件

5：
go get      获取远程包（如果获取google的就需要安装mer的hg 如果获取github上的就需要安装git）
go run      直接运行程序
go build    测试编译检查是否有编译错误
            只有package main 的时候才会生成文件 否则不会生成可执行文件
go fmt      格式化源码(部分IDE在保存的时候会自动调用)
go install  编译安装包并编译整个程序 生成安装文件
go test     运行测试文件
go doc      查看文档(CHM手册)
*********************
*** 规则：
***     大写字母开头的变量是可以导出的，也就是其他的包可以读取。 是公用变量。 小写字母开头的就不可以导出，是私有变量
***     大写字母开头的函数也是一样 相当于class中的带 public 关键词的共有函数；小写字母开头的就是private关键词的私有函数
*********************
6：
go 数组
https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.2.md
① array    定义方式：var arr [n]type     非指针类型  改变赋值后的变量 源数据不变
知道数组有几位   一般的固定型数组用array
例如： [3]int{1, 2, 3} // 声明了一个长度为3的int数组
       [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0
       [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度
       多维数组例子：[2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}
② slice    定义方式：var fslice []int    
    slice 只能是索引数组那样 不可以是关联数组
    除了没有定义[]中的数组值的个数其他与array一样    指针类型  改变赋值后的变量 源数据也变化是,它是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值
不知道数组有几位 可能增长的数组 用slice slice可以从一个数组或一个已经存在的slice中再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。
例如： [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}  //声明一个含有10个元素元素类型为byte的数组
    slice一些简便操作
        slice的默认开始位置是0，ar[:n]等价于ar[0:n]
        slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]
        如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]
    slice有几个有用的内置函数：
        len 获取slice的长度
        cap 获取slice的最大容量
        append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice
        copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数
            append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) == 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响。
************************************************************************************************************************************
注意：注意slice和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用...自动计算长度，而声明slice时，方括号内没有任何字符
************************************************************************************************************************************
③ map
字典  定义方式：map[keyType]valueType
    map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是｀int｀类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型
    map 的key可以是纯数字 也可以是字符串 即php的关联数组
    map 使用时需要注意的几点：
        map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取
        map的长度是不固定的，也就是和slice一样，也是一种引用类型
        内置的len函数同样适用于map，返回map拥有的key的数量
        map的值可以很方便的修改，通过numbers["one"]=11可以很容易的把key为one的字典值改为11
        map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制
    map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式

